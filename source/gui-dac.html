<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>構成図エディタ GUI-DAC ジーユーアイ・ダック</title>
<style>
<!--
* { margin: 0px; padding: 0px; }
svg { border:solid 1px #a02180; }

body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
}

#svgArea {
    width: 100%;
    height: 100%;
    background-color: #f0f0f0;
}

.menuArea {
    width: 100%;
    height: 30px;
    background-color: rgba(128, 128, 128, 0.5);
    position: absolute; /* Position the div within the SVG area */
    top: 0px; /* Initial top position */
    left: 0px; /* Initial left position */
    cursor: grab; /* Show grab cursor for dragging */
    overflow: hidden;
    padding-left: 10px; /* 左側のインデント */
    padding-right: 10px; /* 右側のインデント */
    padding-top: 10px; /* 上側のインデント */
    padding-bottom: 10px; /* 下側のインデント */
}


.menuObjectArea {
    width: 20%;
    height: 50%;
    background-color: rgba(128, 128, 128, 0.5);
    position: absolute; /* Position the div within the SVG area */
    top: 60px; /* Initial top position */
    right: 10px; /* Initial left position */
    cursor: grab; /* Show grab cursor for dragging */
    overflow: hidden;
    padding-left: 10px; /* 左側のインデント */
    padding-right: 10px; /* 右側のインデント */
    padding-top: 10px; /* 上側のインデント */
    padding-bottom: 10px; /* 下側のインデント */
}





.menu01 {
    width: 99%;
    height: 300px;
    bottom: 40px;
    left: 0.5%;
    background-color: #2356ff;
    position: absolute;
}


main {
    height: calc(100% - 60px);
    -js-display: flex;
    display: -webkit-box;
    display: -webkit-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-flex-wrap: wrap;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    padding: 0px;
}

div.area00 {
    width: calc(100%);
    height: 30px;
    margin: 0px;
    overflow: hidden;
    background-color: #D3D3D3;
}

div.area100 {
    width:  calc(100%);
    height: 30px;
    margin: 0px;
    overflow: hidden;
    background-color: #D3D3D3;
}

main div.area01 {
    width: 100px;
    height: calc(100% - 10px);
    margin: 5px;
    overflow: hidden;
    background-color: #D3D3D3;
}
main div.area02 {
    width: calc(75% - 10px);
    height: calc(100% - 10px);
    margin: 5px;
    overflow: hidden;
    background-color: #FFFFFF;
}
main div.area03 {
    width: calc(15% - 10px);
    height: calc(100% - 10px);
    margin: 5px;
    overflow-x: hidden;
    overflow-y: scroll;
    background-color: #D3D3D3;
}

textarea {
  padding-left: 5px; /* 左側に余白を追加 */
  box-sizing: border-box; /* パディングを含めたボックスサイズを設定 */
}

-->
</style>

</head>
<body>


<div class="menuArea" id="menuArea">
    <input class="styled" type="button" value="コード(Code)" onClick="changeMenuAreaSize('menuArea', 'CHANGE');" />
    <input type="file" id="file" accept="application/json">
    <input class="styled" type="button" value="追加" onClick="addObject();" />

    <BR /><BR />
    <input class="styled" type="button" value="反映" onClick="loadDacsetFromArea();" />
    <BR />
    <textarea rows="60" cols="60" id="codeArea" style="font-size: 18px;"></textarea>


</div>

<div class="menuObjectArea" id="menuObjectArea">
    <input class="styled" type="button" value="反映" onClick="loadObjsetFromArea('RENEW');" />
    <input class="styled" type="button" value="削除" onClick="loadObjsetFromArea('DELETE');" />
    <BR />
    <textarea rows="30" cols="36" id="objectArea" style="font-size: 18px;"></textarea>
</div>



<svg id="svgArea"></svg>

<div id="debugArea2"></div>
<div id="debugArea"> </div>
<div id="debugArea3"></div>
<div id="debugArea4"></div>




<script>
const reader = new FileReader();
let SvgArea = 'svgArea'; // SVGタグのID
let ImgCommonPath = 'parts/'; // 画像の格納パス
let OriginalAiconSize1 = 40;
let AiconSize1 = OriginalAiconSize1;
let SPACEVAL = 10; // 図形が移動する間隔
let OriginalFontHight = 20;
let FontHight = OriginalFontHight;
let moveChildFlg = [];
let menuAreaFlg = "SMALL";  // メニューエリアの状態フラグ
let scale = 1.0;
let guiOperateFlg = true;  // GUI操作の有効(true)／無効(false)
//const adjustmentX = 120;  // マウスポイント座標の位置補正(X軸)
//const adjustmentY = 10;  // マウスポイント座標の位置補正(Y軸)

let lineHightLight;  // 接続線のハイライト機能の有効(ON)／無効フラグ


dacsetRuleVersion = "2024-03-31";



// 四角形に配置するアイコン画像の配置場所
let aiconPositions = ["imgTL","imgTR","imgBL","imgBR","imgCE","imgCL","imgCR","imgCT","imgCB"];

//let movedObjs = [];

// 構成図に関する情報をここに全て書く
let dacset = {
    "rule" : "2024-07-21",
    "objs" : [
{label: "CANVAS","ns":"", "x": -30000, "y": -30000, "w":60000, "h":60000, color: "none", opacity: "1.0", group: "gr-Root", "child-layers":["gr0","gr1","gr2","gr3","gr4"], "child": [], line: "NONE", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "OriginalAiconSize1": 40, "lineHightLight": "OFF","FontHight": 20, "SPACEVAL": 10},

{label: "AWS01","ns":"0123456789", "x": 20, "y": 20, "w":1240, "h":1000, color: "none", opacity: "1.0", group: "gr0", "child-layers":["gr1","gr2","gr3","gr4"], "child": [], line: "#000000", imgTL: "aws.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "VPC01","ns":"vpc-01", "x": 240, "y": 90, "w":630, "h":700, color: "none", opacity: "1.0", group: "gr1", "child-layers":["gr2","gr3","gr4"], "child": [], line: "#8C4FFF", imgTL: "vpc.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "VPC02","ns":"vpc-02", "x": 240, "y": 870, "w":620, "h":120, color: "none", opacity: "1.0", group: "gr1","child-layers":["gr2","gr3","gr4"], "child": [], line: "#8C4FFF", imgTL: "vpc.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "PubSub01","ns":"Public01", "x": 270, "y": 160, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": [], line: "#7AA116", imgTL: "PublicSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PubSub02","ns":"Public02", "x": 270, "y": 390, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": [], line: "#7AA116", imgTL: "PublicSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PubSub03","ns":"Public03", "x": 270, "y": 560, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": [], line: "#7AA116", imgTL: "PublicSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "PriSub01","ns":"Private01", "x": 470, "y": 160, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["EC201"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PriSub02","ns":"Private02",  "x": 470, "y": 380, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["EC202"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PriSub03","ns":"Private03",  "x": 470, "y": 560, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["EC202"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "PriSub04","ns":"Private04", "x": 670, "y": 160, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["RDS01"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PriSub05","ns":"private05", "x": 670, "y": 380, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["RDS02"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "PriSub06","ns":"private06", "x": 670, "y": 560, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["RDS02"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "ALB01","ns":"ALB01", "x": 330, "y": 210, "w":80, "h":290, color: "none", opacity: "1.0", group: "gr4", "child-layers":["gr2"],"child": ["PubSub01","PubSub02"], line: "#8C4FFF", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "alb.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "EC201","ns":"EC2-01", "x": 540, "y": 240, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "ec2.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},
{label: "EC202","ns":"EC2-02", "x": 530, "y": 460, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "ec2.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},
{label: "EC203","ns":"EC2-03", "x": 740, "y": 630, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "ec2.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},

{label: "RDS01","ns":"RDS-01", "x": 740, "y": 240, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "rds.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},
{label: "RDS02","ns":"RDS-02", "x": 740, "y": 460, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "rds.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},

{label: "igw01","ns":"", "x": 220, "y": 340, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "igw.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "igw02","ns":"", "x": 220, "y": 910, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "igw.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},

{label: "vpeer01","ns":"", "x": 450, "y": 770, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "vpc-peer.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "OFF"},
{label: "vpeer02","ns":"", "x": 450, "y": 850, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "vpc-peer.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "OFF"},

{label: "VPC03","ns":"vpc-03", "x": 970, "y": 90, "w":260, "h":240, color: "none", opacity: "1.0", group: "gr1","child-layers":["gr2","gr3","gr4"], "child": [], line: "#8C4FFF", imgTL: "vpc.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "VPC03PriSub01","ns":"Private", "x": 1020, "y": 150, "w":170, "h":150, color: "none", opacity: "1.0", group: "gr2","child-layers":["gr3"], "child": ["EC201"], line: "#00A4A6", imgTL: "PrivateSubnet.png", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "NONE","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "ON"},
{label: "VPC03EC201","ns":"EC2-0301", "x": 1080, "y": 220, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "ec2.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtCE", "transFlg": "ON"},

{label: "vpeer03","ns":"", "x": 850, "y": 200, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "vpc-peer.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "OFF"},
{label: "vpeer04","ns":"", "x": 950, "y": 200, "w":40, "h":40, color: "none", opacity: "1.0", group: "gr3", "child": [], line: "none", imgTL: "NONE", imgTR: "NONE", imgBL: "NONE", imgBR: "NONE", imgCE: "vpc-peer.png","imgCL":"NONE","imgCR":"NONE","imgCT":"NONE","imgCB":"NONE","imgSize": 1.0, "txtPosition": "txtTL", "transFlg": "OFF"},

    ],
    "connects" : [
        {
            "id":"n001-1", "color":"red","opa":1.0,"aline":3,"cirSize":0.8,"angle":0,"lineGap":"2,0","cirStrokeWidth":0.1,"edgeEnd": "Triangle",
            "conns": [ "igw01","ALB01","EC201","RDS01" ]
        },
        {
            "id":"n001-2", "color":"red","opa":1.0,"aline":3,"cirSize":0.8,"angle":0,"lineGap":"2,0","cirStrokeWidth":0.1,"edgeEnd": "Triangle",
            "conns": [ "ALB01","EC202","RDS01" ]
        },
        {
            "id":"n003", "color":"#000000","opa":0.8,"aline":4,"cirSize":0.6,"angle":0,"lineGap":"1,0","cirStrokeWidth":0.05,"edgeEnd": "NONE",
            "conns": [ "RDS01","RDS02" ]
        },
        {
            "id":"n004", "color":"#343456","opa":0.8,"aline":10,"cirSize":0.6,"angle":0,"lineGap":"1,0","cirStrokeWidth":0.2,"edgeEnd": "NONE",
            "conns": [ "vpeer01","vpeer02" ]
        },
        {
            "id":"n005", "color":"#343456","opa":0.8,"aline":10,"cirSize":0.6,"angle":0,"lineGap":"1,0","cirStrokeWidth":0.2,"edgeEnd": "NONE",
            "conns": [ "vpeer03","vpeer04" ]
        },
        {
            "id":"n006", "color":"#a489F0","opa":1.0,"aline":4,"cirSize":0.8,"angle":0,"lineGap":"3,0","cirStrokeWidth":0.1,"edgeEnd": "Triangle",
            "conns": [ "EC203","vpeer03","vpeer04","VPC03EC201" ]
        }
    ]
};


let objs = dacset["objs"]; // dacsetから図形描画の情報を格納
let connects = dacset["connects"]; // dacsetから接続線の情報を格納

// マウスで選択した図形の情報
let drag = {
    action : null,
    isMouseDown : false,
    id : null, target: null, offsetx: 0, offsety: 0, w: null,h: null,
    cTarget: false, cDifferencex: 0, cDifferencey: 0,
    group: null,
    ctlId: null, ctlTarget: null, ctlElement: null, ctlOffsetx:0, ctlOffsety: 0,
    ctrId: null, ctrTarget: null, ctrElement: null, ctrOffsetx:0, ctrOffsety: 0,
    cblId: null, cblTarget: null, cblElement: null, cblOffsetx:0, cblOffsety: 0,
    cbrId: null, cbrTarget: null, cbrElement: null, cbrOffsetx:0, cbrOffsety: 0,
    rangeX: null, rangeY: null
}

// マウスで選択した図形以外の情報を移動するときにここに情報を格納する
let nDrag = {
    action : null,
    isMouseDown : false,
    id : null, target: null, offsetx: 0, offsety: 0,
    cTarget: false, cDifferencex: 0, cDifferencey: 0,
    group: null,
    ctlId: null, ctlTarget: null, ctlElement: null, ctlOffsetx:0, ctlOffsety: 0,
    ctrId: null, ctrTarget: null, ctrElement: null, ctrOffsetx:0, ctrOffsety: 0,
    cblId: null, cblTarget: null, cblElement: null, cblOffsetx:0, cblOffsety: 0,
    cbrId: null, cbrTarget: null, cbrElement: null, cbrOffsetx:0, cbrOffsety: 0,
    rangeX: null, rangeY: null
}


let vGap = 10;

let recordConsoleLogFlg = 0;  // recordConsoleLog関数で使うフラグ

function recordConsoleLog(argFlg, argString){
    if(argFlg == 1){
        console.log(argString);
    }
}


function calculateDistance(Ax, Ay, Bx, By) {
    // 座標(Ax,Ay) と (Bx,By) の距離を算出
    const distance = Math.sqrt((Bx - Ax) ** 2 + (By - Ay) ** 2);
    return distance;
}


// テキストを表示
function addText(svgFld, x, y, txt, id) {
    recordConsoleLog(recordConsoleLogFlg, "関数 addText 開始");
    this.text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    this.text.setAttributeNS(null,"x", x);
    this.text.setAttributeNS(null,"y", y);
    this.text.textContent = txt;
    this.text.setAttributeNS(null,"id", id);  // テキスト要素にIDを付与
    text.setAttributeNS(null, "font-size", FontHight);  // フォントサイズを設定

    text.setAttributeNS(null, "text-anchor", "start");  // 左揃えを設定
    //text.setAttributeNS(null, "text-anchor", "middle");  // 中央揃えを設定
    //text.setAttributeNS(null, "text-anchor", "end");  // 右揃えを設定

    document.getElementById(svgFld).appendChild(this.text);
    recordConsoleLog(recordConsoleLog, "関数 addText 終了");
}

// 対象図形の全テキストを移動
function moveTextFlow(tgtId){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveTextFlow 開始");
    x = objs[tgtId]["x"];
    y = objs[tgtId]["y"];
    w = objs[tgtId]["w"];
    h = objs[tgtId]["h"];
    imgTL = objs[tgtId]["imgTL"];
    imgSize = objs[tgtId]["imgSize"];
    imgTL   = objs[tgtId]["imgTL"];
    imgCE   = objs[tgtId]["imgCE"];
    iTxtPosition   = objs[tgtId]["txtPosition"];

    label = objs[tgtId]["label"];

    tgttxts = [];

    //四角形の左上に配置するテキスト
    let tlX;
    let tlY;

    switch(iTxtPosition){
        case "txtTL":
            // テキストをTopLeftに配置
            if(imgTL != "NONE"){
                tlX = x+AiconSize1*imgSize;
            }else{
                tlX = x+5;
            }
            tlY = y+FontHight;
            break;

        case "txtCE":
            // テキストをCenterに配置
            tlX = x+5;
            if(imgCE != "NONE"){
                tlY = y+w*0.5+FontHight+AiconSize1*imgSize*0.5;
            }else{
                tlX = y+FontHight;
            }
            break;
    }

    let tlL = objs[tgtId]["label"];
    let tlId= tgtId + "txtTL";
    tgttxts.push( [tlX,tlY,tlL,tlId] );

    for(let i = 0; i < tgttxts.length; i++) {
        let curX = tgttxts[i][0];  // X座標
        let curY = tgttxts[i][1];  // Y座標
        let curText = tgttxts[i][2];  // テキスト
        let curId = tgttxts[i][3];  // SVGキャンパス上のID

        if(curText != "NONE"){
            const ImageElement = document.getElementById(curId); // ID で選択
            ImageElement.setAttributeNS(null, "x", curX);
            ImageElement.setAttributeNS(null, "y", curY);
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 moveTextFlow 終了");
}


function addAiconFlow(argId,argIx,argIy,argIw,argIh,argImgSize){
    recordConsoleLog(recordConsoleLogFlg, "関数 addAiconFlow 開始");
    for(nowPosition of aiconPositions){
        let nowAiconId = null;
        let nowAiconX = null;
        let nowAiconY = null;
        let nowAiconPath = null;

        let imgPos = objs[argId][nowPosition];
        //nowAiconPath = ImgCommonPath + imgPos;
        if (imgPos.startsWith("http")) {
            // 先頭文字列 'http' の場合
            nowAiconPath = imgPos;
        } else {
            // 先頭文字列 'http' ではない場合
            nowAiconPath = ImgCommonPath + imgPos;
        }

        if(imgPos != "NONE"){
            switch(nowPosition){
                case "imgTL":
                    //四角形の左上に配置する画像
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx;
                    nowAiconY = argIy;
                    break;

                case "imgTR":
                    //四角形の右上に配置する画像
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx+argIw-AiconSize1*argImgSize;
                    nowAiconY = argIy;
                    break;

                case "imgBL":
                    //四角形の左下に配置する画像
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx;
                    nowAiconY = argIy+argIh-AiconSize1*argImgSize;
                    break;

                case "imgBR":
                    //四角形の右下に配置する画像
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx+argIw-AiconSize1*argImgSize;
                    nowAiconY = argIy+argIh-AiconSize1*argImgSize;
                    break;


                case "imgCE":
                    //四角形の中央に配置する画像
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx + 0.5*argIw - 0.5*AiconSize1*argImgSize;
                    nowAiconY = argIy + 0.5*argIh - 0.5*AiconSize1*argImgSize;
                    break;

                case "imgCL":
                    //四角形の左辺の中央
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx - 0.5*AiconSize1*argImgSize;
                    nowAiconY = argIy + 0.5*argIh;
                    break;

                case "imgCR":
                    //四角形の右辺の中央
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx + argIw - 0.5*AiconSize1*argImgSize;
                    nowAiconY = argIy + 0.5*argIh;
                    break;

                case "imgCT":
                    //四角形の上辺の中央
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx + argIw*0.5;
                    nowAiconY = argIy - 0.5*AiconSize1*argImgSize;
                    break;


                case "imgCB":
                    //四角形の下辺の中央
                    nowAiconId = argId + nowPosition;
                    nowAiconX = argIx + argIw*0.5;
                    nowAiconY = argIy + argIh - 0.5*AiconSize1*argImgSize;
                    break;
            }
            addAicon(SvgArea, nowAiconX, nowAiconY, AiconSize1*argImgSize, AiconSize1*argImgSize, nowAiconPath, nowAiconId);
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 addAiconFlow 終了");
}


// アイコン(画像)を表示
function addAicon(svgFld, x, y, width, height, imageUrl, imageId) {
    recordConsoleLog(recordConsoleLogFlg, "関数 addAicon 開始");
    const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
    image.setAttributeNS(null, "x", x);
    image.setAttributeNS(null, "y", y);
    image.setAttributeNS(null, "width", width);
    image.setAttributeNS(null, "height", height);
    image.setAttributeNS("http://www.w3.org/1999/xlink", "href", imageUrl);
    image.setAttributeNS(null, "id", imageId); // ID を追加

    // 回転
    //tmpAngle = 30;
    //let cx = x + width / 2;
    //let cy = y + height / 2;
    //image.setAttributeNS(null, "transform", `rotate(${tmpAngle}, ${cx}, ${cy})`);

    document.getElementById(svgFld).appendChild(image);
    //moveChildFlg[imageId] = 0;
    recordConsoleLog(recordConsoleLogFlg, "関数 addAicon 終了");
}


// 1つのアイコン(画像)を移動
function moveAicon(imageId, x, y){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveAicon 開始");
    const ImageElement = document.getElementById(imageId); // ID で選択
    ImageElement.setAttributeNS(null, "x", x);
    ImageElement.setAttributeNS(null, "y", y);
    recordConsoleLog(recordConsoleLogFlg, "関数 moveAicon 終了");
}


// moveChildFlg を 0 にリセットする
function setMoveChildFlg(){
    recordConsoleLog(recordConsoleLogFlg, "関数 setMoveChildFlg 開始");
    for (let iLavel in moveChildFlg) {
        if (moveChildFlg.hasOwnProperty(iLavel)) {
            moveChildFlg[iLavel] = 0;
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 setMoveChildFlg 終了");
}


// 対象図形の全アイコン(画像)を移動
function moveAiconFlow(tgtId){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveAiconFlow 開始");
    x = objs[tgtId]["x"];
    y = objs[tgtId]["y"];
    w = objs[tgtId]["w"];
    h = objs[tgtId]["h"];
    size = objs[tgtId]["imgSize"];

    label = objs[tgtId]["label"];

    tgtaicons = [];

    //四角形の左上に配置する画像
    let tlX = x;
    let tlY = y;
    let tlA = objs[tgtId]["imgTL"];
    let tlId= tgtId + "imgTL";
    tgtaicons.push( [tlX,tlY,tlA,tlId] );

    //四角形の右上に配置する画像
    let trX = x + w-AiconSize1*size;
    let trY = y;
    let trA = objs[tgtId]["imgTR"];
    let trId= tgtId + "imgTR";
    tgtaicons.push( [trX,trY,trA,trId] );

    //四角形の左下に配置する画像
    let blX = x;
    let blY = y + h -AiconSize1*size;
    let blA = objs[tgtId]["imgBL"];
    let blId= tgtId + "imgBL";
    tgtaicons.push( [blX,blY,blA,blId] );

    //四角形の右下に配置する画像
    let brX = x + w -AiconSize1*size;
    let brY = y + h -AiconSize1*size;
    let brA = objs[tgtId]["imgBR"];
    let brId= tgtId + "imgBR";
    tgtaicons.push( [brX,brY,brA,brId] );

    //四角形の中央に配置する画像
    let ceX = x + 0.5*w -0.5*AiconSize1*size;
    let ceY = y + 0.5*h -0.5*AiconSize1*size;
    let ceA = objs[tgtId]["imgCE"];
    let ceId= tgtId + "imgCE";
    tgtaicons.push( [ceX,ceY,ceA,ceId] );


    //四角形の左辺の中央に配置する画像
    let clX = x - 0.5*AiconSize1*size;
    let clY = y + 0.5*h;
    let clA = objs[tgtId]["imgCL"];
    let clId= tgtId + "imgCL";
    tgtaicons.push( [clX,clY,clA,clId] );

    //四角形の右辺の中央に配置する画像
    let crX = x + w - 0.5*AiconSize1*size;
    let crY = y + 0.5*h;
    let crA = objs[tgtId]["imgCR"];
    let crId= tgtId + "imgCR";
    tgtaicons.push( [crX,crY,crA,crId] );

    //四角形の上辺の中央に配置する画像
    let ctX = x + w*0.5;
    let ctY = y - 0.5*AiconSize1*size;
    let ctA = objs[tgtId]["imgCT"];
    let ctId= tgtId + "imgCT";
    tgtaicons.push( [ctX,ctY,ctA,ctId] );


    //四角形の下辺の中央に配置する画像
    let cbX = x + w*0.5;
    let cbY = y + h - 0.5*AiconSize1*size;
    let cbA = objs[tgtId]["imgCB"];
    let cbId= tgtId + "imgCB";
    tgtaicons.push( [cbX,cbY,cbA,cbId] );

    for(let i = 0; i < tgtaicons.length; i++) {
        let curX = tgtaicons[i][0];  // X座標
        let curY = tgtaicons[i][1];  // Y座標
        let curAicon = tgtaicons[i][2];  // アイコン画像名
        let curId = tgtaicons[i][3];  // SVGキャンパス上のID

        if(curAicon != "NONE"){
            const ImageElement = document.getElementById(curId); // ID で選択
            ImageElement.setAttributeNS(null, "x", curX);
            ImageElement.setAttributeNS(null, "y", curY);

            moveChildFlg[label] = 1;  // フラグを変更
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 moveAiconFlow 終了");
}

// 対象図形のアイコンやテキストなどを移動
function moveOptionFlow(tgtId){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveOptionFlow 開始 rangeX="+drag.rangeX+", rangeY="+drag.rangeY);
    moveAiconFlow(tgtId);  // アイコン移動
    moveTextFlow(tgtId);  // テキスト移動
    moveConnectFlow(tgtId);  // 接続線の移動
    updateParentChildParam(tgtId);  // 親・子の設定を更新する
    recordConsoleLog(recordConsoleLogFlg, "関数 moveOptionFlow 終了");
}


// 昇順に並べ替える関数
function sortByGroup(data) {
    return data.sort((a, b) => {
        if (a.group < b.group) {
            return -1;
        }
        if (a.group > b.group) {
            return 1;
        }
        return 0;
    });
}


function moveConnectFlow(argId){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnectFlow 開始");
    const tgtLabel = objs[argId]["label"];  // 対象図形のラベル
    for (let i in connects) {
        const connectsStr = connects[i]["conns"];
        const connectId = connects[i]["id"];
        const connectCirSize= connects[i]["cirSize"] * AiconSize1;
        const connectAngle = connects[i]["angle"];
        const connectEdgeEnd = connects[i]["edgeEnd"];


        if (connectsStr.includes(tgtLabel)) {
            moveConnect(tgtLabel, connectId,connects[i]["conns"],connectCirSize,connectAngle,connectEdgeEnd);  // 接続線を移動する
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnectFlow 終了");
}

// 接続線と円に必要な情報を作る
function calcConnectInfo(argTgtLabel,argConnId,argConnects){
    recordConsoleLog(recordConsoleLogFlg, "関数 calcConnectInfo 開始");
    const tgtIndex = argConnects.indexOf(argTgtLabel);
    const tgtLabel = argConnects[tgtIndex];
    const tgtObject = getObjInfo(tgtLabel);
    const tgtObjX = tgtObject.x;
    const tgtObjY = tgtObject.y;
    const tgtObjW = tgtObject.w;
    const tgtObjH = tgtObject.h;
    const tgtCirX = tgtObjX + tgtObjW*0.5;
    const tgtCirY = tgtObjY + tgtObjH*0.5;
    const tgtCircleId = argConnId+"-"+tgtLabel;  // 接続の円のID
    const tgtConnId = tgtCircleId+"-con";  // 接続線のID

    //console.log(argConnId);




    recordConsoleLog(recordConsoleLogFlg, "関数 calcConnectInfo 終了");

    return {"circleId": tgtCircleId, "cirX": tgtCirX, "cirY": tgtCirY, "connId":tgtConnId};
}

// 接続線を移動する
function moveConnect(argTgtLabel, argConnId,argConnects,argCirSize,argAngle,argEdgeEnd){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnect 開始");
    const nowSet = calcConnectInfo(argTgtLabel,argConnId,argConnects);
    moveCircleToCoordinates(nowSet.circleId, nowSet.cirX, nowSet.cirY);  //argTgtLabelを囲む(接続線の)円の移動

    // 接続線の移動
    const index = argConnects.indexOf(argTgtLabel);
    let nxtTgtLabel = "";
    let nxtSet = "";
    let nxtPnt = "";
    let befTgtLabel = "";
    let befSet = "";
    let befPnt = "";

    if(index == 0){
        // 接続線の 0 番目のオブジェクトを選択した場合
        nxtTgtLabel = argConnects[index+1];
        nxtSet = calcConnectInfo(nxtTgtLabel,argConnId,argConnects);  // 隣(+1)の円の情報
        nxtPnt = calculatePoints(nowSet.cirX,nowSet.cirY,nxtSet.cirX,nxtSet.cirY,argCirSize,argAngle); // 接続線2点の始点と終点を算出する
        moveConnectToCoordinates(nxtSet.connId,nxtPnt["start"]["x"], nxtPnt["start"]["y"], nxtPnt["end"]["x"], nxtPnt["end"]["y"]);  // 接続線を移動する



        if(argEdgeEnd == "Triangle"){
            moveConnectEdge(nxtSet.connId+"-EdgeEnd",nxtPnt["start"]["x"], nxtPnt["start"]["y"], nxtPnt["end"]["x"], nxtPnt["end"]["y"]);  //矢印(三角形)を移動する
        }

    }else if(index < argConnects.length-1){
        // 接続線の中間のオブジェクトを選択した場合
        nxtTgtLabel = argConnects[index+1];
        nxtSet = calcConnectInfo(nxtTgtLabel,argConnId,argConnects);  // 隣(+1)の円の情報
        nxtPnt = calculatePoints(nowSet.cirX,nowSet.cirY,nxtSet.cirX,nxtSet.cirY,argCirSize,argAngle); // 接続線2点の始点と終点を算出する
        moveConnectToCoordinates(nxtSet.connId,nxtPnt["start"]["x"], nxtPnt["start"]["y"], nxtPnt["end"]["x"], nxtPnt["end"]["y"]);  // 接続線を移動する

        befTgtLabel = argConnects[index-1];
        befSet = calcConnectInfo(befTgtLabel,argConnId,argConnects);  // 隣(-1)の円の情報
        befPnt = calculatePoints(befSet.cirX,befSet.cirY,nowSet.cirX,nowSet.cirY,argCirSize,argAngle); // 接続線2点の始点と終点を算出する
        moveConnectToCoordinates(nowSet.connId,befPnt["start"]["x"], befPnt["start"]["y"], befPnt["end"]["x"], befPnt["end"]["y"]);  // 接続線を移動する

        if(argEdgeEnd == "Triangle"){
            moveConnectEdge(nxtSet.connId+"-EdgeEnd",nxtPnt["start"]["x"], nxtPnt["start"]["y"], nxtPnt["end"]["x"], nxtPnt["end"]["y"]);  //矢印(三角形)を移動する
            moveConnectEdge(nowSet.connId+"-EdgeEnd",befPnt["start"]["x"], befPnt["start"]["y"], befPnt["end"]["x"], befPnt["end"]["y"]);  //矢印(三角形)を移動する
        }
    }else{
        // 接続線の最後のオブジェクトを選択した場合
        befTgtLabel = argConnects[index-1];
        befSet = calcConnectInfo(befTgtLabel,argConnId,argConnects);  // 隣(-1)の円の情報
        befPnt = calculatePoints(befSet.cirX,befSet.cirY,nowSet.cirX,nowSet.cirY,argCirSize,argAngle); // 接続線2点の始点と終点を算出する
        moveConnectToCoordinates(nowSet.connId,befPnt["start"]["x"], befPnt["start"]["y"], befPnt["end"]["x"], befPnt["end"]["y"]);  // 接続線を移動する

        if(argEdgeEnd == "Triangle"){
            moveConnectEdge(nowSet.connId+"-EdgeEnd",befPnt["start"]["x"], befPnt["start"]["y"], befPnt["end"]["x"], befPnt["end"]["y"]);  //矢印(三角形)を移動する
        }
    }








    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnect 終了");
}


// 円を移動する
function moveCircleToCoordinates(circleId, cirX, cirY) {
    recordConsoleLog(recordConsoleLogFlg, "関数 moveCircleToCoordinates 開始");
    const ImageElement = document.getElementById(circleId); // ID で選択
    ImageElement.setAttributeNS(null, "cx", cirX);
    ImageElement.setAttributeNS(null, "cy", cirY);
    recordConsoleLog(recordConsoleLogFlg, "関数 moveCircleToCoordinates 終了");
}

// 線を移動する
function moveConnectToCoordinates(connectLineId, Ax,Ay,Bx,By) {
    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnectToCoordinates 開始");
    const ImageElement = document.getElementById(connectLineId); // ID で選択
    ImageElement.setAttributeNS(null, "x1", Ax);
    ImageElement.setAttributeNS(null, "y1", Ay);
    ImageElement.setAttributeNS(null, "x2", Bx);
    ImageElement.setAttributeNS(null, "y2", By);
    recordConsoleLog(recordConsoleLogFlg, "関数 moveConnectToCoordinates 終了");
}


// 矢印(三角形)を移動する
function moveConnectEdge(edgeID,argSx,argSy,argEx,argEy) {
    //console.log("[moveConnectEdge] edgeID = " + edgeID);
    let arrowCoordinates = calculateArrowCoordinates(argSx,argSy,argEx,argEy);
    triA1x = arrowCoordinates[0]["x"];
    triA1y = arrowCoordinates[0]["y"];
    triA2x = arrowCoordinates[1]["x"];
    triA2y = arrowCoordinates[1]["y"];
    triA3x = arrowCoordinates[2]["x"];
    triA3y = arrowCoordinates[2]["y"];
    //triId = nowConnectId+"-EdgeEnd";  // 接続線の終端のオブジェクト
    const ImageElement = document.getElementById(edgeID); // ID で選択
    ImageElement.setAttributeNS(null, "points", `${triA1x},${triA1y} ${triA2x},${triA2y} ${triA3x},${triA3y}`);

}





// SVG Line (線)
function svgLine(svgFld, Ax, Ay, Bx, By, color, opa, id, aline, dasharray){
    recordConsoleLog(recordConsoleLogFlg, "関数 svgLine 開始");
    this.line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    this.line.setAttributeNS(null, "x1", Ax);
    this.line.setAttributeNS(null, "y1", Ay);
    this.line.setAttributeNS(null, "x2", Bx);
    this.line.setAttributeNS(null, "y2", By);
    this.line.setAttributeNS(null, "id", id);
    this.line.setAttributeNS(null, 'stroke-width', aline);
    line.setAttributeNS(null, "stroke-dasharray", dasharray); // 破線の設定 5pxの線と5pxのギャップ


    if(lineHightLight == "ON"){
        // 接続線のハイライト有効
        this.line.setAttributeNS(null, "stroke", "gray");
        this.line.setAttributeNS(null, "stroke-opacity", 0.3);

        this.line.addEventListener('mouseover', function() {
            highlightConnect('mouseover', id, color, opa);
        });
        this.line.addEventListener('mouseout', function() {
            highlightConnect('mouseout', id, color, opa);
        });
    }else{
        // 接続線のハイライト無効
        this.line.setAttributeNS(null, "stroke", color);
        this.line.setAttributeNS(null, "stroke-opacity", opa);
    }




    document.getElementById(svgFld).appendChild(this.line);
    recordConsoleLog(recordConsoleLogFlg, "関数 svgLine 終了");
}



//接続線にハイライトをあてる
function highlightConnect(mouseFlg, argId, orgColor, argOpa){

    let parts = argId.split('-');
    let searchString = parts[0];

    // ID に searchString を含む全ての SVG 要素を取得
    let elements = document.querySelectorAll(`[id*="${searchString}"]`);
    
    elements.forEach(element => {
        if (element) {
            console.log(element["id"]);
            // マウスオーバー時
            if (mouseFlg === 'mouseover') {
                element.setAttributeNS(null, 'stroke', orgColor);
                element.setAttributeNS(null, "stroke-opacity", argOpa);
                if (element["id"].indexOf("-EdgeEnd") !== -1) {
                    element.setAttributeNS(null, 'fill', orgColor);
                    element.setAttributeNS(null, 'fill-opacity', argOpa);
                }
            } 
            // マウスアウト時
            else if (mouseFlg === 'mouseout') {
                element.setAttributeNS(null, 'stroke', 'gray'); // 色を元に戻す
                element.setAttributeNS(null, "stroke-opacity", 0.3);
                if (element["id"].indexOf("-EdgeEnd") !== -1) {
                    element.setAttributeNS(null, 'fill', 'gray');
                    element.setAttributeNS(null, 'fill-opacity', 0.3);
                }
            }
        }
    });
}
















//SVG Rect(四角)
function svgRect(svgFld,x,y,w,h,color,opa,id,aline){
    recordConsoleLog(recordConsoleLogFlg, "関数 svgRect 開始");
    this.rect=document.createElementNS("http://www.w3.org/2000/svg","rect");
    this.rect.setAttributeNS(null,"x",x);
    this.rect.setAttributeNS(null,"y",y);
    this.rect.setAttributeNS(null,"width",w);
    this.rect.setAttributeNS(null,"height",h);
    this.rect.setAttributeNS(null,"fill", color);
    this.rect.setAttributeNS(null,"fill-opacity", opa);
    this.rect.setAttributeNS(null,"id", id);
    this.rect.setAttributeNS(null, 'stroke', aline);


    // 回転
    //tmpAngle = 30;
    //this.rect.setAttributeNS(null, "transform", `rotate(${tmpAngle}, ${x}, ${y})`);


    document.getElementById(svgFld).appendChild(this.rect);
    recordConsoleLog(recordConsoleLogFlg, "関数 svgRect 終了");
}

//SVG Circle(円)
function svgCircle(svgFld,cx,cy,rVal,colorFill,colorStroke,opacity1,opacity2,opacity3,id,dasharray,cirStrokeWidth){
    recordConsoleLog(recordConsoleLogFlg, "関数 svgCircle 開始");
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", cx);
    this.circle.setAttribute("cy", cy);
    this.circle.setAttribute("r", rVal);
    this.circle.setAttribute("fill", colorFill);
    this.circle.setAttribute("stroke-width", cirStrokeWidth);
    this.circle.setAttribute("stroke-dasharray", dasharray);
    this.circle.setAttribute("opacity", opacity1);
    this.circle.setAttribute("fill-opacity", opacity2);
    this.circle.setAttribute("stroke-opacity", 0.3);
    this.circle.setAttribute("transform", "rotate(0)");
    

    if(lineHightLight == "ON"){
        // 接続線のハイライト有効
        this.circle.setAttribute("stroke", "gray");
        this.circle.addEventListener('mouseover', function() {
            highlightConnect('mouseover', id, colorStroke, opacity3);
        });
        this.circle.addEventListener('mouseout', function() {
            highlightConnect('mouseout', id, colorStroke, opacity3);
        });
    }else{
        this.circle.setAttribute("stroke", colorStroke);
        this.circle.setAttribute("stroke-opacity", opacity3);        
    }
    
    this.circle.setAttributeNS(null,"id", id);
    document.getElementById(svgFld).appendChild(this.circle);
    
    return( this.circle );
    recordConsoleLog(recordConsoleLogFlg, "関数 svgCircle 終了");
}





//SVG 三角形
//svgTriangle("mySvg", 50, 10, 10, 80, 90, 80, "blue", "black", 1, 0.8, 1, "triangle1", triId);
//(x1, y1), (x2, y2), (x3, y3)は3角形の頂点の座標、colorFillとcolorStrokeは塗りつぶしと枠線の色、opacity1、opacity2、opacity3は不透明度、idは要素のID
function svgTriangle(svgFld, x1, y1, x2, y2, x3, y3, colorFill, colorStroke, opacity1, opacity2, opacity3, triId) {
    recordConsoleLog(recordConsoleLogFlg, "関数 svgTriangle 開始");
    const triangle = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    triangle.setAttribute("points", `${x1},${y1} ${x2},${y2} ${x3},${y3}`);
    triangle.setAttribute("stroke-width", 2);
    triangle.setAttribute("opacity", opacity1);
    triangle.setAttributeNS(null, "id", triId);

    if(lineHightLight == "ON"){
        // 接続線のハイライト有効
        triangle.setAttribute("fill", "gray");
        triangle.setAttribute("fill-opacity", 0.3);
        triangle.setAttribute("stroke", "gray");
        triangle.setAttribute("stroke-opacity", 0.3);

        /*
        triangle.addEventListener('mouseover', function() {
            triangle.setAttribute("fill", colorFill);
            triangle.setAttribute("fill-opacity", opacity2);
            highlightConnect('mouseover', triId, colorStroke, opacity3);
        });
        triangle.addEventListener('mouseout', function() {
            triangle.setAttribute("fill", colorFill);
            triangle.setAttribute("fill-opacity", opacity2);
            highlightConnect('mouseout', triId, colorStroke, opacity3);
        });
        */

    }else{
        // 接続線のハイライト無効
        triangle.setAttribute("fill", colorFill);
        triangle.setAttribute("fill-opacity", opacity2);
        triangle.setAttribute("stroke", colorStroke);
        triangle.setAttribute("stroke-opacity", opacity3);
    }










    document.getElementById(svgFld).appendChild(triangle);
    recordConsoleLog(recordConsoleLogFlg, "関数 svgTriangle 終了");
    return triangle;
}


//SVG 要素の削除
function delElement(svgFld,tgtElement){ // SVG Element削除
    recordConsoleLog(recordConsoleLogFlg, "関数 delElement 開始");
    try{
        document.getElementById(svgFld).removeChild(tgtElement);
    }catch{
        console.log("関数 delElement でエラー");
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 delElement 終了");
}

document.onmouseup = function () {
    recordConsoleLog(recordConsoleLogFlg, "関数 document.onmouseup 開始");
    if(guiOperateFlg == false){
        // GUI操作が無効なら以降の処理をしない
        // console.log("Processing cancelled.");
        return;
    }
    drag.isMouseDown = false;
    if (drag.target != null) {
        //変形後の数値を objs に格納する
        objs[ drag.id ]["w"] = drag.target.width.baseVal.value;
        objs[ drag.id ]["h"] = drag.target.height.baseVal.value;
    }
	drag.target = null;
    recordConsoleLog(recordConsoleLogFlg, "関数 document.onmouseup 終了");
}


function setGuiOperateFlg(){
    // SVG描画領域にマウスがある場合はGUI操作を有効にする
    let divGuiNegative = ['menuArea', 'objectArea'];
    let divGuiActive = ['svgArea'];
    let loGuiOperateFlg = false;

    divGuiActive.forEach(function(id) {
        let target = document.getElementById(id);
        if (target.contains(event.target)) {
            loGuiOperateFlg = true;
        }
    });

    divGuiNegative.forEach(function(id) {
        // メニュー領域にマウスがある場合はGUI操作を無効にする
        let target = document.getElementById(id);
        if (target.contains(event.target)) {
            loGuiOperateFlg = false;
        }
    });

    return loGuiOperateFlg;
}




document.onmousemove = onmousemovefnc;

function onmousemovefnc(e){
    recordConsoleLog(recordConsoleLogFlg, "関数 onmousemovefnc 開始");

    guiOperateFlg = setGuiOperateFlg();
    if(guiOperateFlg == false){
        // GUI操作が無効なら以降の処理をしない
        return;
    }

    if (drag.target != null) {
        dragAction(e); // 選択した図形の移動or変形と選択した図形の四隅に描画した円図形の移動
        setMoveChildFlg();  // moveChildFlg を 0 にリセットする

        //-------------------------------------------------------//
        //同じグループの図形は重ならないようにする
        let debugStr="";
        let tgXArr = new Array(); // 選択した図形と同じグループの左上のX座標
        let tgXorign = 0;
        let tX = drag.target.x.baseVal.value;
        let tW = drag.target.width.baseVal.value;
        let tY = drag.target.y.baseVal.value;
        let tH = drag.target.height.baseVal.value;

        tgXArr.length = 0;
        for (let i in objs) {
            if( objs[i]["group"] == drag.group ){ // 選択していない図形のみ処理
                let originFlg = "";
                if( i == drag.id ) originFlg = "ORIGIN";

                // 選択した図形からの距離
                let distance = calculateDistance(tX, tY, objs[i]["x"], objs[i]["y"]);

                curArr = [ Number(i) , objs[i]["x"] , objs[i]["w"] , originFlg, distance ];
                tgXArr.push( curArr );
            }
        }
        tgXArr.sort(function(a,b){return(a[4] - b[4]);}); // 選択した図形からの距離が近い順に並べる

        moveOptionFlow(drag.id);  // 対象図形のアイコンやテキストなどを移動

        // 図形を重ならないように並べる前に、起点(ORIGIN)となる情報を設定する
        tgXArr.forEach( (row, i) => {
            if( row[3] == "ORIGIN" ){
                tgXorign = i;
            }
        });

        let tmpX = tgXArr[tgXorign][1] + tgXArr[tgXorign][2] + vGap;
        let nxtX = 0;

        //////////////////////////////////////////////////////////////////////
        //---- 選択した図形より右側にある同じグループの図形を移動する [START]----//
        for(let ilp=tgXorign+1; ilp< tgXArr.length; ilp++){
            setSameGroupObjsRight(tgXArr, ilp, tgXorign, tX,tY,tW,tH);
        }
        //---- 選択した図形より右側にある同じグループの図形を移動する [END]----//
        //////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////
        //---- 選択した図形より左側にある同じグループの図形を移動する [START]----//
        for(let ilp=tgXorign-1; ilp>= 0; ilp--){
            setSameGroupObjsLeft(tgXArr, ilp, tgXorign, tX,tY,tW,tH);
        }
        //---- 選択した図形より左側にある同じグループの図形を移動する [END]----//
        //////////////////////////////////////////////////////////////////////

        //////////////////////////////////////////////////////////////////////
        //---- childの図形を移動する [START]----//
        moveChildElement(drag.id,drag.rangeX,drag.rangeY);  // child要素の図形を移動する
        //---- childの図形を移動する [END]----//
        //////////////////////////////////////////////////////////////////////
    }
    //recordConsoleLog(recordConsoleLogFlg, "関数 onmousemovefnc 終了");
}


function showInfoToObjectArea(){
    // objectArea に選択した図形の情報を表示
    const objarea = document.getElementById("objectArea");
    objset = objs[ drag.id ];
    if (objset.child) {
        // child配下をクリア
        objset.child = [];
    }
    objarea.value = JSON.stringify(objset, null, 2);  // textareaにコード(objset)を登録
}


function loadObjsetFromArea(argFlg){
    // 反映：textarea(objectArea)からコードを読み取り、変数 dacset に格納する
    recordConsoleLog(recordConsoleLogFlg, "関数 loadDacsetFromArea 開始");
    try{
        const objarea = document.getElementById('objectArea');
        const objtext = objarea.value;
        objset = JSON.parse(objtext);

        if( argFlg == "RENEW"){
            // 対象のオブジェクトをtextarea(objectArea)の情報に上書きする
            dacset.objs = dacset.objs.map(obj => 
                obj.label === objset.label ? { ...obj, ...objset } : obj
            );
        }else if ( argFlg == "DELETE"){
            // 対象のオブジェクトをtextarea(objectArea)の情報に基づいて削除する
            dacset.objs = dacset.objs.filter(obj => obj.label !== objset.label);
        }


        // 再描画の処理
        objs = dacset["objs"]; // dacsetから図形描画の情報を格納
        objs = sortByGroup(objs);  // group要素の値で昇順に並べ替え
        connects = dacset["connects"]; // dacsetから接続線の情報を格納
        firstFlow();  // 構成図を再描画
    }catch (error){
        alert("エラーが発生しました");
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 loadDacsetFromArea 終了");
}



function generateRandomString(length) {
    const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        result += characters[randomIndex];
    }
    return result;
}

function getRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}


function addObject(){
    // 追加ボタン：オブジェクトを追加する
    addLabel = generateRandomString(18);
    addX = getRandomNumber(100, 200);
    addY = getRandomNumber(100, 200);
    addObj = {
        "label": addLabel,
        "ns": "AddedObject",
        "x": addX,
        "y": addY,
        "w": 50,
        "h": 50,
        "color": "none",
        "opacity": "1.0",
        "group": "gr9999999",
        "child-layers": [],
        "child": [],
        "line": "black",
        "imgTL": "undefined.png",
        "imgTR": "NONE",
        "imgBL": "NONE",
        "imgBR": "NONE",
        "imgCE": "NONE",
        "imgCL": "NONE",
        "imgCR": "NONE",
        "imgCT": "NONE",
        "imgCB": "NONE",
        "imgSize": 1,
        "txtPosition": "txtTL",
        "transFlg": "ON"
    }

    dacset.objs.push(addObj);
    objs = dacset["objs"]; // dacsetから図形描画の情報を格納
    objs = sortByGroup(objs);  // group要素の値で昇順に並べ替え
    connects = dacset["connects"]; // dacsetから接続線の情報を格納
    firstFlow();  // 構成図を再描画
}


document.onmousedown = onmousedownfnc;

function onmousedownfnc(e){
    recordConsoleLog(recordConsoleLogFlg, "関数 onmousedownfnc 開始");
    guiOperateFlg = setGuiOperateFlg();
    if(guiOperateFlg == false){
        // GUI操作が無効なら以降の処理をしない
        // console.log("Processing cancelled.");
        return;
    }
    eX = e.pageX;
    eY = e.pageY;

    let ditectFlg = 0; // クリックしたところに図形があると 1 にする
    let cRadius = 5; // 選択した図形の四隅に描画する円の半径

    for (let i = objs.length - 1; i >= 0; i--){
        iId    = i;
        iXmin  = objs[i]["x"];
        iXmax  = objs[i]["x"] + objs[i]["w"];
        iYmin  = objs[i]["y"];
        iYmax  = objs[i]["y"] + objs[i]["h"];

        if (iXmin <= eX && eX < iXmax){ // マウスポインタのX座標が図形の範囲内にあるか？
            if (iYmin <= eY && eY < iYmax){ // マウスポインタのX座標が図形の範囲内にある場合、Y座標は範囲内にあるか？
                ditectFlg = 1;
                let chIdFlg = 0;
                if(iId != drag.id){
                    chIdFlg = 1;
                    if (drag.cTarget != false) {
                        delElement(SvgArea , drag.ctlElement); drag.ctlElement = null; // 左上の円
                        delElement(SvgArea , drag.ctrElement); drag.ctrElement = null; // 右上の円
                        delElement(SvgArea , drag.cblElement); drag.cblElement = null; // 左下の円
                        delElement(SvgArea , drag.cbrElement); drag.cbrElement = null; // 右下の円
                        drag.cTarget = false;
                    }
                }

                // 変数 drag に選択した図形の情報を設定
                setDragVal(Number(iId),e); // 変数 drag に対象図形の情報を格納

                // objectArea に選択した図形の情報を表示
                showInfoToObjectArea();

                //-----------------------------------------------------//
                if(drag.cTarget != true){
                    if(chIdFlg == 1){

                        drag.cTarget = true;
                        const dasharray = "1,3";  // 破線の設定
                        const cirStrokeWidth = 2.0
                        //四角形の左上(TopLeft)の円
                        drag.ctlId = drag.id + "tl";
                        drag.ctlElement = svgCircle(SvgArea,objs[ drag.id ]["x"]+cRadius, objs[ drag.id ]["y"]+cRadius,cRadius*2,'#a899bb','none',0.9,0.8,0.5 , drag.ctlId,dasharray,cirStrokeWidth);
                        drag.ctlTarget = document.getElementById( drag.ctlId );

                        //四角形の右上(TopRight)の円
                        drag.ctrId = drag.id + "tr";
                        drag.ctrElement = svgCircle(SvgArea, objs[ drag.id ]["x"]+objs[ drag.id ]["w"]-cRadius, objs[ drag.id ]["y"]+cRadius,cRadius*2,'#9ba89b','none',0.9,0.8,0.5 , drag.ctrId,dasharray,cirStrokeWidth);
                        drag.ctrTarget = document.getElementById( drag.ctrId );

                        //四角形の左下(BottomLeft)の円
                        drag.cblId = drag.id + "bl";
                        drag.cblElement = svgCircle(SvgArea, objs[ drag.id ]["x"]+cRadius, objs[ drag.id ]["y"]+objs[ drag.id ]["h"]-cRadius,cRadius*2,'#9ba89b','none',0.9,0.8,0.5 , drag.cblId,dasharray,cirStrokeWidth);
                        drag.cblTarget = document.getElementById( drag.cblId );

                        //四角形の右下(BottomRight)の円
                        drag.cbrId = drag.id + "br";
                        drag.cbrElement = svgCircle(SvgArea, objs[ drag.id ]["x"]+objs[ drag.id ]["w"]-cRadius, objs[ drag.id ]["y"]+objs[ drag.id ]["h"]-cRadius,cRadius*2,'#9ba89b','none',0.9,0.8,0.5 , drag.cbrId,dasharray,cirStrokeWidth);
                        drag.cbrTarget = document.getElementById( drag.cbrId );
                    }
                }

                cRadius = cRadius * 1.2;
                drag.cDifferencex= e.clientX; // 円移動に使うオフセット(X座標)
                drag.cDifferencey= e.clientY; // 円移動に使うオフセット(Y座標)

                drag.ctrOffsetx = e.clientX - objs[ drag.id ]["x"] - objs[ drag.id ]["w"]+cRadius; // 右上の円(X座標)
                drag.ctrOffsety = e.clientY - objs[ drag.id ]["y"] - cRadius;                      // 右上の円(Y座標)
                drag.ctlOffsetx = e.clientX - objs[ drag.id ]["x"] - cRadius;                      // 左上の円(X座標)
                drag.ctlOffsety = e.clientY - objs[ drag.id ]["y"] - cRadius;                      // 左上の円(Y座標)
                drag.cblOffsetx = e.clientX - objs[ drag.id ]["x"] - cRadius;                      // 左下の円(X座標)
                drag.cblOffsety = e.clientY - objs[ drag.id ]["y"] - objs[ drag.id ]["h"]+cRadius; // 左下の円(Y座標)
                drag.cbrOffsetx = e.clientX - objs[ drag.id ]["x"] - objs[ drag.id ]["w"]+cRadius; // 右下の円(X座標)
                drag.cbrOffsety = e.clientY - objs[ drag.id ]["y"] - objs[ drag.id ]["h"]+cRadius; // 右下の円(Y座標)

                // drag.action (Move or Transform) の決定
                let rangeVal = cRadius*2;
                let cx1min = objs[ drag.id ]["x"] -rangeVal;
                let cx1max = objs[ drag.id ]["x"] +rangeVal;
                let cx2min = objs[ drag.id ]["x"] + objs[ drag.id ]["w"] -rangeVal;
                let cx2max = objs[ drag.id ]["x"] + objs[ drag.id ]["w"] +rangeVal;

                let cy1min = objs[ drag.id ]["y"] -rangeVal;
                let cy1max = objs[ drag.id ]["y"] +rangeVal;
                let cy2min = objs[ drag.id ]["y"] + objs[ drag.id ]["h"] -rangeVal;
                let cy2max = objs[ drag.id ]["y"] + objs[ drag.id ]["h"] +rangeVal;

                drag.action = "Move";
                if( drag.transflg == "ON"){
                    if( cx1min <= eX && eX <= cx1max ){
                        if( cy2min <= eY && eY <= cy2max ){
                            drag.action = "Transform-Y";
                        }
                    }else if( cx2min <= eX && eX <= cx2max ){
                        if( cy1min <= eY && eY <= cy1max ){
                            drag.action = "Transform-X";
                        }else  if( cy2min <= eY && eY <= cy2max ){
                            drag.action = "Transform-XY";
                        }
                    }
                }
                break;
            }
        }
    }
    if(ditectFlg == 0){    //クリックしたところに図形がなった場合
        if (drag.cTarget != false) {
            initialDragVal(); // drag の初期化           
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 onmousedownfnc 終了");
}


function dragAction(e){ // 選択した図形の移動or変形と選択した図形の四隅に描画した円図形の移動
    recordConsoleLog(recordConsoleLogFlg, "関数 dragAction 開始");

    drag.rangeX = 0;  // 移動量(X)の初期化
    drag.rangeY = 0;  // 移動量(Y)の初期化

    if( drag.action == "Move"){
        drag.target.x.baseVal.value = Math.round((e.clientX - drag.offsetx)/SPACEVAL)*SPACEVAL; // 選択した図形の移動(X軸)
        drag.target.y.baseVal.value = Math.round((e.clientY - drag.offsety)/SPACEVAL)*SPACEVAL; // 選択した図形の移動(Y軸)

        let dragIdBeforeX = objs[ drag.id ]["x"];  // 移動前の座標
        let dragIdBeforeY = objs[ drag.id ]["y"];  // 移動前の座標

        objs[ drag.id ]["x"] = drag.target.x.baseVal.value; // 変数 objs の更新
        objs[ drag.id ]["y"] = drag.target.y.baseVal.value; // 変数 objs の更新

        let dragIdAfterX = objs[ drag.id ]["x"];  // 移動後の座標
        let dragIdAfterY = objs[ drag.id ]["y"];  // 移動後の座標

        drag.ctlTarget.cx.baseVal.value = objs[ drag.id ]["x"]; // 左上の円(X座標)
        drag.ctlTarget.cy.baseVal.value = objs[ drag.id ]["y"]; // 左上の円(Y座標)
        drag.ctrTarget.cx.baseVal.value = objs[ drag.id ]["x"] + objs[ drag.id ]["w"]; // 右上の円(X座標)
        drag.ctrTarget.cy.baseVal.value = objs[ drag.id ]["y"]; // 右上の円(Y座標)
        drag.cblTarget.cx.baseVal.value = objs[ drag.id ]["x"]; // 左下の円(X座標)
        drag.cblTarget.cy.baseVal.value = objs[ drag.id ]["y"] + objs[ drag.id ]["h"]; // 左下の円(Y座標)
        drag.cbrTarget.cx.baseVal.value = objs[ drag.id ]["x"] + objs[ drag.id ]["w"]; // 右下の円(X座標)
        drag.cbrTarget.cy.baseVal.value = objs[ drag.id ]["y"] + objs[ drag.id ]["h"]; // 右下の円(Y座標)

        document.getElementById("debugArea2").innerHTML = "(Move) drag.id="+drag.id+ ", label="+ objs[ drag.id ]["label"] + ", x=" + objs[ drag.id ]["x"] +", y="+ objs[ drag.id ]["y"];

        drag.rangeX = dragIdAfterX - dragIdBeforeX;  // 移動量(X)
        drag.rangeY = dragIdAfterY - dragIdBeforeY;  // 移動量(Y)

    }else if( drag.action == "Transform-X"){ // 図形の変形(X方向のみ)
        drag.target.width.baseVal.value  = drag.w + Math.round((e.clientX - drag.cDifferencex)/SPACEVAL)*SPACEVAL; // 選択した図形の変形(X軸)

        objs[ drag.id ]["w"] = drag.target.width.baseVal.value; // 変数 objs の更新

        drag.ctrTarget.cx.baseVal.value = e.clientX - drag.ctrOffsetx; // 右上の円(X座標)
        drag.cbrTarget.cx.baseVal.value = e.clientX - drag.cbrOffsetx; // 左下の円(X座標)

    }else if( drag.action == "Transform-Y"){ // 図形の変形(Y方向のみ)
        drag.target.height.baseVal.value = drag.h + Math.round((e.clientY - drag.cDifferencey)/SPACEVAL)*SPACEVAL; // 選択した図形の変形(Y軸)

        objs[ drag.id ]["h"] = drag.target.height.baseVal.value;

        drag.cblTarget.cy.baseVal.value = e.clientY - drag.cblOffsety; // 左下の円(Y座標)
        drag.cbrTarget.cy.baseVal.value = e.clientY - drag.cbrOffsety; // 左下の円(Y座標)

    }else if( drag.action == "Transform-XY"){ // 図形の変形
        drag.target.width.baseVal.value  = drag.w + Math.round((e.clientX - drag.cDifferencex)/SPACEVAL)*SPACEVAL; // 選択した図形の変形(X軸)
        drag.target.height.baseVal.value = drag.h + Math.round((e.clientY - drag.cDifferencey)/SPACEVAL)*SPACEVAL; // 選択した図形の変形(Y軸)
        objs[ drag.id ]["w"] = drag.target.width.baseVal.value; // 変数 objs の更新
        objs[ drag.id ]["h"] = drag.target.height.baseVal.value; // 変数 objs の更新
        drag.ctrTarget.cx.baseVal.value = e.clientX - drag.ctrOffsetx; // 右上の円(X座標)
        drag.cblTarget.cy.baseVal.value = e.clientY - drag.cblOffsety; // 左下の円(Y座標)
        drag.cbrTarget.cx.baseVal.value = e.clientX - drag.cbrOffsetx; // 左下の円(X座標)
        drag.cbrTarget.cy.baseVal.value = e.clientY - drag.cbrOffsety; // 左下の円(Y座標)

    }
    recordConsoleLog(recordConsoleLogFlg, "関数 dragAction 終了");
}


function setDragVal(argId,argE){ // 変数 drag に対象図形の情報を格納
    recordConsoleLog(recordConsoleLogFlg, "関数 setDragVal 開始");
    drag.id = Number(argId);
    drag.target = document.getElementById( drag.id );
    drag.offsetx = argE.clientX - objs[ drag.id ]["x"];
    drag.offsety = argE.clientY - objs[ drag.id ]["y"];
    drag.isMouseDown = true;
    drag.group = objs[ drag.id ]["group"];
    drag.w = objs[ drag.id ]["w"];
    drag.h = objs[ drag.id ]["h"];
    drag.transflg = objs[ drag.id ]["transFlg"];
    recordConsoleLog(recordConsoleLogFlg, "関数 setDragVal 終了");
} 



// 変数 drag の初期化
function initialDragVal(){
    recordConsoleLog(recordConsoleLogFlg, "関数 initialDragVal 開始");
    delElement(SvgArea , drag.ctlElement); drag.ctlElement = null; // 左上の円
    delElement(SvgArea , drag.ctrElement); drag.ctrElement = null; // 右上の円
    delElement(SvgArea , drag.cblElement); drag.cblElement = null; // 左下の円
    delElement(SvgArea , drag.cbrElement); drag.cbrElement = null; // 右下の円
    drag.action = null;
    drag.isMouseDown = false;
    drag.id = null; drag.target = null; drag.offsetx = 0; drag.offsety = 0;
    drag.cTarget = false; drag.cDifferencex = 0; drag.cDifferencey = 0;
    drag.ctlId = null; drag.ctlTarget=null; drag.ctlElement=null; drag.ctlOffsetx=0; drag.ctlOffsety=0;
    drag.ctrId = null; drag.ctrTarget=null; drag.ctrElement=null; drag.ctrOffsetx=0; drag.ctrOffsety=0;
    drag.cbrId = null; drag.cbrTarget=null; drag.cbrElement=null; drag.cbrOffsetx=0; drag.cbrOffsety=0;
    drag.cblId = null; drag.cblTarget=null; drag.cblElement=null; drag.cblOffsetx=0; drag.cblOffsety=0;
    drag.group = null;
    drag.rangeX = null;
    drag.rangeY = null;
    drag.transflg = null;
    recordConsoleLog(recordConsoleLogFlg, "関数 initialDragVal 終了");
}


document.getElementById('file').addEventListener('change', function(event) {
    // 読み込んだJSONファイルから構成図を描画する
    const file = event.target.files[0];
    if (file) {
        const codearea = document.getElementById("codeArea");
        let nowDacset;
        const reader = new FileReader();
        reader.onload = function(e) {
            const jsonContent = e.target.result;
            try {
                dacset = JSON.parse(jsonContent);
                if (objs.some(subArray => subArray.length !== 0)) {
                    clearArray(objs);  // objsをクリア
                }

                if (connects.some(subArray => subArray.length !== 0)) {
                    clearArray(connects);  // connectsをクリア
                }

                objs = dacset["objs"]; // dacsetから図形描画の情報を格納
                connects = dacset["connects"]; // dacsetから接続線の情報を格納

                firstFlow();  // 構成図を再描画

            } catch (error) {
                console.error("JSONの解析中にエラーが発生しました:", error);
            }
        };
        reader.readAsText(file);

        codearea.value = JSON.stringify(dacset, null, 2);  // textareaにコード(dacset)を登録
    }

});














function firstFlow(){
    recordConsoleLog(recordConsoleLogFlg, "関数 firstFlow 開始");

    // 最初にSVGエリアに構成図を描画する処理
    ///////////////////////
    // 倍率を設定する
    setInit();  // 初期設定

    ///////////////////////
    // 倍率を設定する
    setObjectRatio();

    ///////////////////////
    // 四角形を描画するフロー
    addObjectFlow();

    ///////////////////////
    // 接続線を描画するフロー
    addConnectFlow();

    recordConsoleLog(recordConsoleLogFlg, "関数 firstFlow 終了");
}


window.onload = firstFlow();


// 2次元配列をクリアする関数
function clearArray(array) {
    recordConsoleLog(recordConsoleLogFlg, "関数 clearArray 開始");
    for (let i = 0; i < array.length; i++) {
        if (array[i].length !== 0) {
            array[i] = [];
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 clearArray 終了");
}

function setInit(){
    recordConsoleLog(recordConsoleLogFlg, "関数 setInit 開始");
    const svgElement = document.getElementById('svgArea');
    // 子要素をすべて削除
    while (svgElement.firstChild) {
        svgElement.removeChild(svgElement.firstChild);
    }

    scale = 1.0;
    OriginalAiconSize1 = dacset["objs"][0]["OriginalAiconSize1"] !== undefined ? dacset["objs"][0]["OriginalAiconSize1"] : 40;
    AiconSize1 = orgRound(OriginalAiconSize1, scale);
    FontHight = dacset["objs"][0]["FontHight"] !== undefined ? dacset["objs"][0]["FontHight"] : 20;
    SPACEVAL = dacset["objs"][0]["SPACEVAL"] !== undefined ? dacset["objs"][0]["SPACEVAL"] : 10;
    lineHightLight = dacset["objs"][0]["lineHightLight"] !== undefined ? dacset["objs"][0]["lineHightLight"] : "OFF";

    moveChildFlg = [];
    guiOperateFlg = true;  // GUI操作の有効(true)／無効(false)
    vGap = 10;

    recordConsoleLog(recordConsoleLogFlg, "関数 setInit 終了");
}



// 倍率(sale)を元にサイズ/座標を更新する
function setObjectRatio(){
    recordConsoleLog(recordConsoleLogFlg, "関数 setObjectRatio 開始");
    AiconSize1 = orgRound(AiconSize1, scale);
    FontHight = FontHight * scale;
    for (let i in objs) {
        objs[i]["x"] = orgRound(objs[i]["x"], scale);
        objs[i]["y"] = orgRound(objs[i]["y"], scale);
        objs[i]["w"] = orgRound(objs[i]["w"], scale);
        objs[i]["h"] = orgRound(objs[i]["h"], scale);
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 setObjectRatio 終了");
}


// 小数点以下を四捨五入する
function orgRound(argBase,argValue) {
    recordConsoleLog(recordConsoleLogFlg, "関数 orgRound 開始");
    argBase = argBase * argValue;
    recordConsoleLog(recordConsoleLogFlg, "関数 orgRound 終了");
    return Math.round(argBase);
}


// 四角形を描画するフロー
function addObjectFlow(){
    recordConsoleLog(recordConsoleLogFlg, "関数 addObjectFlow 開始");
    for (let i in objs) { // 四角形を描画
        iId      = i;
        iX       = objs[i]["x"];
        iY       = objs[i]["y"];
        iW       = objs[i]["w"];
        iH       = objs[i]["h"];
        iColor   = objs[i]["color"];
        iOpacity = objs[i]["opacity"];
		iLabel   = objs[i]["label"];
        iNs      = objs[i]["ns"];  // 表示する文字(name-short)
		iLine    = objs[i]["line"];
        iImgSize = objs[i]["imgSize"];  // 画像のサイズ
        iImgTL   = objs[i]["imgTL"];
        iImgCE   = objs[i]["imgCE"];
        iTxtPosition   = objs[i]["txtPosition"];
        svgRect(SvgArea,iX,iY,iW,iH,iColor,iOpacity,iId,iLine);

        moveChildFlg[iLabel] = 0;
        
        addAiconFlow(iId,iX,iY,iW,iH,iImgSize);

        // テキストlabelを表示
        switch(iTxtPosition){
            case "txtTL":
                // テキストをTopLeftに配置
                if(iImgTL != "NONE"){
                    txtX = iX+AiconSize1*iImgSize;
                }else{
                    txtX = iX+5;
                }
                txtY = iY+FontHight;
                break;

            case "txtCE":
                // テキストをCenterに配置
                txtX = iX+5;
                if(iImgCE != "NONE"){
                    //txtY = iY+FontHight+AiconSize1*iImgSize;
                    txtY = iY+iH*0.5+FontHight+AiconSize1*iImgSize*0.5;
                }else{
                    txtX = iY+iH*0.5+FontHight;
                }
                break;
        }

        addText(SvgArea, txtX, txtY, iNs, iId+"txtTL");
        //addText(SvgArea, iX+AiconSize1, iY+FontHight, iNs, iId+"txtTL");
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 addObjectFlow 終了");
}


// 接続線を描画するフロー
function addConnectFlow(){
    recordConsoleLog(recordConsoleLogFlg, "関数 addConnectFlow 開始");
    dacset.connects.forEach(connect => {
        const nowConnectId = connect.id;  // 接続線のID
        const nowColor = connect.color;  // 接続線の色
        const nowOpa = connect.opa;  // 接続線の透明度
        const nowAline = connect.aline;  // 接続線の線幅
        const nowAngle = connect.angle;  // 接続線を引くときの角度設定
        const nowConnObjs = connect.conns;  // 接続線をつなぐオブジェクトの配列
        const dashedLineGap  = connect.lineGap;  // 接続線の破線の間隔
        const nowSize = AiconSize1*connect.cirSize;  // 接続線をつなぐオブジェクトの配列
        const nowCirStrokeWidth = AiconSize1*connect.cirStrokeWidth;  // 接続円の線幅
        const nowEdgeEnd  = connect.edgeEnd;  // 終端の設定

        const edLabel = null;
        connect.conns.forEach((nowLabel, index) => {
            const nowCircleId = nowConnectId+"-"+nowLabel;  // 接続線をつなぐ円のID
            const nowConnectLineId = nowCircleId+"-con";  // 接続線のID
            const triId = nowConnectLineId +"-EdgeEnd";  // 接続線の終端のオブジェクト

            //console.log(nowCircleId + ", " + nowConnectLineId);

            if (index > 0) {
                const edPoint = calcConnectPoint(nowLabel);  // 中点(終点)
                const stPoint = calcConnectPoint(stLabel);  // 中点(始点)
                const points = calculatePoints(stPoint["x"], stPoint["y"], edPoint["x"], edPoint["y"], nowSize, nowAngle); // 接続線2点の始点と終点を算出する

                svgLine(SvgArea, points["start"]["x"], points["start"]["y"], points["end"]["x"], points["end"]["y"], nowColor, nowOpa, nowConnectLineId, nowAline,dashedLineGap);
                svgCircle(SvgArea,edPoint["x"],edPoint["y"],nowSize,"none",nowColor,nowOpa,nowOpa,nowOpa,nowCircleId,dashedLineGap,nowCirStrokeWidth);  // 終点の円

                //矢印(三角形)
                let arrowCoordinates = calculateArrowCoordinates(points["start"]["x"], points["start"]["y"], points["end"]["x"], points["end"]["y"]);
                triA1x = arrowCoordinates[0]["x"];
                triA1y = arrowCoordinates[0]["y"];
                triA2x = arrowCoordinates[1]["x"];
                triA2y = arrowCoordinates[1]["y"];
                triA3x = arrowCoordinates[2]["x"];
                triA3y = arrowCoordinates[2]["y"];
                

                if(nowEdgeEnd == "Triangle"){
                    // 終端に矢印(三角形)を描画
                    //svgTriangle(SvgArea, triA1x, triA1y, triA2x, triA2y, triA3x, triA3y, "blue", "black", 1, 0.8, 1, triId);
                    svgTriangle(SvgArea, triA1x, triA1y, triA2x, triA2y, triA3x, triA3y, nowColor, "", 1.0, nowOpa, 1, triId);
                }


            }else{
                const stPoint = calcConnectPoint(nowLabel);  // 中点(始点)
                svgCircle(SvgArea,stPoint["x"],stPoint["y"],nowSize,"none",nowColor,nowOpa,nowOpa,nowOpa,nowCircleId,dashedLineGap,nowCirStrokeWidth);  // 始点の円
            }
            stLabel = nowLabel;
        });
    });
    recordConsoleLog(recordConsoleLogFlg, "関数 addConnectFlow 終了");
}





// 矢印の三角形の座標を算出
function calculateArrowCoordinates(xs, ys, xe, ye) {
    // 矢印の長さと幅を設定
    const arrowLength = 15;
    const arrowWidth = 10;

    // 直線の方向ベクトルを求める
    const dx = xe - xs;
    const dy = ye - ys;
    const lineLength = Math.sqrt(dx * dx + dy * dy);

    // 矢印の方向ベクトルを正規化
    const ux = dx / lineLength;
    const uy = dy / lineLength;

    // 矢印の翼のベクトルを求める
    const vx = -uy * arrowWidth;
    const vy = ux * arrowWidth;

    // 三角形の頂点を計算
    const xt1 = xe;
    const yt1 = ye;
    const xt2 = xe - ux * arrowLength + vx;
    const yt2 = ye - uy * arrowLength + vy;
    const xt3 = xe - ux * arrowLength - vx;
    const yt3 = ye - uy * arrowLength - vy;

    return [
        { x: xt1, y: yt1 },
        { x: xt2, y: yt2 },
        { x: xt3, y: yt3 }
    ];
}


































// 接続線の座標算出
function calcConnectPoint(argLabel){
    recordConsoleLog(recordConsoleLogFlg, "関数 calcConnectPoint 開始");
    const argObject = getObjInfo(argLabel);  // 始点のオブジェクト
    const argObjX = argObject.x;
    const argObjY = argObject.y;
    const argObjW = argObject.w;
    const argObjH = argObject.h;

    const argCenterX = argObjX + argObjW/2;  // 図形オブジェクトの中点(X)
    const argCenterY = argObjY + argObjH/2;  // 図形オブジェクトの中点(Y)
    recordConsoleLog(recordConsoleLogFlg, "関数 calcConnectPoint 終了");
    return {x: argCenterX, y: argCenterY};
}


// 接続線2点の始点と終点を算出する
function calculatePoints(Xa, Ya, Xb, Yb, r, argAngle) {
    recordConsoleLog(recordConsoleLogFlg, "関数 calculatePoints 開始");
    // 点Aと点B間の距離を計算
    let dist = Math.sqrt(Math.pow((Xb - Xa), 2) + Math.pow((Yb - Ya), 2));

    // 点Aと点B間の角度を計算
    let angle = Math.atan2(Yb - Ya, Xb - Xa);

    // 引数に指定された角度を適用
    let angleS = angle - (Math.PI / 180) * argAngle;
    let angleE = angle + (Math.PI / 180) * argAngle;

    // 新しい始点を計算
    let startX = Xa + r * Math.cos(angleS);
    let startY = Ya + r * Math.sin(angleS);

    // 新しい終点を計算
    let endX = Xb - r * Math.cos(angleE);
    let endY = Yb - r * Math.sin(angleE);

    recordConsoleLog(recordConsoleLogFlg, "関数 calculatePoints 終了");

    return {start: {x: startX, y: startY}, end: {x: endX, y: endY}};
}


// 指定ラベルの情報を取得する
function getObjInfo(argLabel){
    recordConsoleLog(recordConsoleLogFlg, "関数 getObjInfo 開始");
    const tgtObject = dacset.objs.find(obj => obj.label === argLabel);
    recordConsoleLog(recordConsoleLogFlg, "関数 getObjInfo 終了");
    return(tgtObject);
}


function showDebuginfo(argFlg,argStr){ // デバッグ用
    recordConsoleLog(recordConsoleLogFlg, "関数 showDebuginfo 開始");
	wStr = "";
    wStr = argStr;
    if(argFlg == 0){
        wStr = "<BR>\n-------<BR>\n";
        wStr += "isMouseDown = "+ drag["isMouseDown"] + "<BR>\n";
        wStr += "target = "  + drag["target"] + "<BR>\n";
        wStr += "offsetx = " + drag["offsetx"] + "<BR>\n";
        wStr += "offsety = " + drag["offsety"] + "<BR>\n";
        wStr += "objs[0] = " + objs[0]["x"] + ", " + objs[0]["y"] +"<BR>\n";
        wStr += "objs[1] = " + objs[1]["x"] + ", " + objs[1]["y"] +"<BR>\n";
        wStr = "<BR>\n-------<BR>\n";
        wStr = "drag.ctlId = " + drag.ctlId + "<BR>";
        wStr = "drag.ctlTarget = " + drag.ctlTarget + "<BR>";
        wStr = "drag.ctrElement = " + drag.ctrElement + "<BR>";
        wStr = "drag.ctlOffsetx = " + drag.ctlOffsetx + "<BR>";
        wStr = "drag.ctlOffcsety = " + drag.ctlOffcsety + "<BR>";
    }
	document.getElementById("debugArea").innerHTML = wStr;
    recordConsoleLog(recordConsoleLogFlg, "関数 showDebuginfo 終了");
}

// 重なりを判定
function judgmentOverlap(arg1Label, arg1Start, arg1Width, arg2Label, arg2Start, arg2Width){
    recordConsoleLog(recordConsoleLogFlg, "関数 judgmentOverlap 開始");
    let judResutl = "INITIAL";    // 判定結果
    let rangeVal = 0; // 重なり量

    arg1Start -= SPACEVAL
    arg1Width += SPACEVAL*2

    let l1s = arg1Start;
    let l1e = arg1Start + arg1Width;
    let l2s = arg2Start;
    let l2e = arg2Start + arg2Width;

    let L1 = [ l1s , l1e ];
    let L2 = [ l2s , l2e ];
    let S1 = (L1[0] - L2[0]) * (L1[1] - L2[1]);
    let S2 = (L1[0] - L2[1]) * (L1[1] - L2[0]);

    if(S1 == 0){
        if(S2 < 0){
            judResutl = "OVERLAP"; // 重なる
        }
    }else if(S1 > 0){
        if(S2 < 0){
            judResutl = "OVERLAP"; // 重なる
        }
    }else if(S1 < 0){
        if(S2 <0){
            //judResutl = "INCLUDED"; // 一方に含まれる
            judResutl = "OVERLAP"; // 重なる
        }
    }
    if(judResutl == "OVERLAP"){
        rangeVal = Math.abs( Math.max(L1[0], L2[0]) - Math.min(L1[1], L2[1]) );
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 judgmentOverlap 終了");
    return [judResutl,rangeVal];
}

///////////////////////////////////////////////////////////
//関数setSameGroupObjsRight(), setSameGroupObjsLeft() の共通処理
function setSameGroupObjsCommon(fncFlg,tgXArr, jlp, tgXorign, tX,tY,tW,tH, nowId, nowX, nowW, nowY, nowH, nowLabel, moveDirect,moveDirectX,moveDirectY,judgeResX,judgeResY){
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsCommon 開始");

    let befId = Number(tgXArr[jlp][0]);
    let befX = objs[befId]["x"];
    let befW = objs[befId]["w"];
    let befY = objs[befId]["y"];
    let befH = objs[befId]["h"];
    let befLabel = objs[befId]["label"];

    if( befId ==  tgXorign){ // 1つ前の図形が選択した図形の場合
        befX = tX;
        befW = tW;
        befY = tY;
        befH = tH;
    }

    judgeResX = judgmentOverlap(nowLabel, nowX, nowW, befLabel, befX, befW);

    if(judgeResX[0] == "OVERLAP" && befLabel != nowLabel){
        judgeResY = judgmentOverlap(nowLabel, nowY, nowH, befLabel, befY, befH);

        if(judgeResY[0] == "OVERLAP"){
            if(nowY <= befY){ moveDirectY = "UP";  }else{ moveDirectY = "DOWN"; }
            if(nowX <= befX){ moveDirectX = "LEFT";}else{ moveDirectX = "RIGHT";}

            if(judgeResX[1] <= judgeResY[1]){ moveDirect = moveDirectX;
            }else{                            moveDirect = moveDirectY;}

            ////////////////////////////////////////////
            //図形の移動
            nDrag.id = Number(nowId); // 対象の図形を変数 nDrag に登録
            nDrag.target = document.getElementById( nDrag.id ); // 対象の図形を変数 nDrag に登録
            let nDragBeforX = objs[nDrag.id]["x"];  // 移動前(X)
            let nDragBeforY = objs[nDrag.id]["y"];  // 移動前(Y)
            if(moveDirect == "RIGHT"){
                nxtX = befX + befW + SPACEVAL;
                nDrag.target.x.baseVal.value = nxtX; // nDrag に登録した図形の移動(X軸)
                objs[nDrag.id]["x"] = nxtX; // objs の情報を更新
            }else if(moveDirect == "LEFT"){
                nxtX = befX - nowW - SPACEVAL;
                nDrag.target.x.baseVal.value = nxtX; // nDrag に登録した図形の移動(X軸)
                objs[nDrag.id]["x"] = nxtX; // objs の情報を更新
            }else if(moveDirect == "DOWN"){
                nxtX = befY + befH + SPACEVAL;
                nDrag.target.y.baseVal.value = nxtX; // nDrag に登録した図形の移動(X軸)
                objs[nDrag.id]["y"] = nxtX; // objs の情報を更新
            }else if(moveDirect == "UP"){
                nxtX = befY - nowH - SPACEVAL;
                nDrag.target.y.baseVal.value = nxtX; // nDrag に登録した図形の移動(X軸)
                objs[nDrag.id]["y"] = nxtX; // objs の情報を更新
            }

            let nDragAfterX = objs[nDrag.id]["x"];  // 移動後(X)
            let nDragAfterY = objs[nDrag.id]["y"];  // 移動後(Y)

            nDrag.rangeX = nDragAfterX - nDragBeforX;  // 移動量(X)
            nDrag.rangeY = nDragAfterY - nDragBeforY;  // 移動量(Y)

            // アイコン移動
            moveOptionFlow(nDrag.id);  // 対象図形のアイコンやテキストなどを移動

            // child要素の図形を移動する
            moveChildElement(nDrag.id, nDrag.rangeX, nDrag.rangeY);

            document.getElementById("debugArea3").innerHTML = "(nDrag) nDrag.id=" + nDrag.id+", "+nowX+", "+nowW+", "+befX+", "+befW+", moveDirect=" + moveDirect;
        }else{
            showDebuginfo(1,"重ならない(Y軸)");
            document.getElementById("debugArea3").innerHTML = "(nDrag) 重ならない(Y軸) nDrag.id=" + nDrag.id;
        }
    }else{
        showDebuginfo(1,"重ならない(X軸) judgeResX = " + judgeResX);
        document.getElementById("debugArea3").innerHTML = "(nDrag) 重ならない(X軸) nDrag.id=" + nDrag.id;
    }
    debugStr+= "nowId: "+nowId + ", nowX: " + nowX + ", befId: " +befId+ ", befX: "+ befX+ ", moveDirect: "+ moveDirect + "<BR />";
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsCommon 終了");
}


function setSameGroupObjsRight(tgXArr, ilp, tgXorign, tX,tY,tW,tH){
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsRight 開始");
    // 同じクループの図形を重なりが発生しないように移動する
    let nowId= tgXArr[ilp][0];
    let nowX = objs[nowId]["x"];
    let nowW = objs[nowId]["w"];
    let nowY = objs[nowId]["y"];
    let nowH = objs[nowId]["h"];
    let nowLabel = objs[nowId]["label"];

    let jVal = ""; // 重なりの判定結果
    let moveDirect = "INITIAL"; // 移動方向(最終決定)
    let moveDirectX = "moveDirectX"; // 移動方向(X方向)
    let moveDirectY = "moveDirectY"; // 移動方向(Y方向)
    let judgeResX = "DUMMY";
    let judgeResY = "DUMMY";

    debugStr = "";

    for(let jlp=tgXorign; jlp< ilp; jlp++){
        setSameGroupObjsCommon("RightFnc",tgXArr, jlp, tgXorign, tX,tY,tW,tH, nowId, nowX, nowW, nowY, nowH, nowLabel, moveDirect,moveDirectX,moveDirectY,judgeResX,judgeResY);        
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsRight 終了");
}


function setSameGroupObjsLeft(tgXArr, ilp, tgXorign, tX,tY,tW,tH){ // 同じクループの図形を重なりが発生しないように移動する
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsLeft 開始");
    let nowId= tgXArr[ilp][0];
    let nowX = objs[nowId]["x"];
    let nowW = objs[nowId]["w"];
    let nowY = objs[nowId]["y"];
    let nowH = objs[nowId]["h"];
    let nowLabel = objs[nowId]["label"];

    let jVal = ""; // 重なりの判定結果
    let moveDirect = "INITIAL"; // 移動方向(最終決定)
    let moveDirectX = "moveDirectX"; // 移動方向(X方向)
    let moveDirectY = "moveDirectY"; // 移動方向(Y方向)
    let judgeResX = "DUMMY";
    let judgeResY = "DUMMY";

    debugStr = "";

    for(let jlp=tgXorign; jlp>=0; jlp--){
        setSameGroupObjsCommon("LeftFnc",tgXArr, jlp, tgXorign, tX,tY,tW,tH, nowId, nowX, nowW, nowY, nowH, nowLabel, moveDirect,moveDirectX,moveDirectY,judgeResX,judgeResY);
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 setSameGroupObjsLeft 終了");
}


// 親(parent)要素を動かしたときに子(child)要素の図形を移動する
function moveChildElement(parentId, nowRangeX, nowRangeY){
    recordConsoleLog(recordConsoleLogFlg, "関数 moveChildElement 開始");
    objs.forEach((element, elemId) => {
        let curLabal = element["label"];

        if(objs[parentId]["child"].includes(element["label"])){

            if(moveChildFlg[curLabal] == 0 ){
                //図形の移動
                //console.log("1_親(parent)要素を動かしたときに子(child)要素の図形を移動する nowRangeX = " + nowRangeX + ", nowRangeY = " + nowRangeY);
                nDrag.id = Number(elemId); // 対象の図形を変数 nDrag に登録
                nDrag.target = document.getElementById( nDrag.id ); // 対象の図形を変数 nDrag に登録

                if(nowRangeX != 0){
                    nxtX = nDrag.target.x.baseVal.value + drag.rangeX;
                    nDrag.target.x.baseVal.value = nxtX; // nDrag に登録した図形の移動(X軸)
                    objs[nDrag.id]["x"] = nxtX; // objs の情報を更新
                    //console.log("[moveChildElement] moved-X");
                }

                if(nowRangeY != 0){
                    nxtY = nDrag.target.y.baseVal.value + drag.rangeY;
                    nDrag.target.y.baseVal.value = nxtY; // nDrag に登録した図形の移動(Y軸)
                    objs[nDrag.id]["y"] = nxtY; // objs の情報を更新
                    //console.log("[moveChildElement] moved-Y");
                }
                // アイコンや接続線の移動
                moveOptionFlow(nDrag.id);  // 対象図形のアイコンやテキストなどを移動
                moveChildFlg[label]["aicon"] = 1;  // Childフラグを変更
            }
        }
    });
    recordConsoleLog(recordConsoleLogFlg, "関数 moveChildElement 終了");
}


// 親・子の設定を更新する
function updateParentChildParam(argId){
    recordConsoleLog(recordConsoleLogFlg, "関数 updateParentChildParam 開始");
    const nowLabel = objs[argId]["label"];  // 対象オブジェクトのラベル
    let nowParents = objs[argId]["parent"];  // 対象オブジェクトのparent要素
    let nowChilds = objs[argId]["child"];  // 対象オブジェクトのchild要素
    let nowX = objs[argId]["x"];  // 対象オブジェクトのx座標
    let nowY = objs[argId]["y"];  // 対象オブジェクトのy座標
    let nowW = objs[argId]["w"];  // 対象オブジェクトの幅(w)
    let nowH = objs[argId]["h"];  // 対象オブジェクトの高さ(h)
    let nowChildLayers = objs[argId]["child-layers"];  // 対象オブジェクトのchild属性になるレイヤー(group)
    
    for( lp in nowChildLayers){
        const childLyer = nowChildLayers[lp];
        const childObjs = dacset.objs.filter(obj => obj.group === childLyer);

        for (objNo in childObjs){
            let judObj = childObjs[objNo];
            let judLabel = judObj["label"];
            let judX = judObj["x"];
            let judY = judObj["y"];
            let judW = judObj["w"];
            let judH = judObj["h"];
            const jresX = judgmentOverlap(nowLabel, nowX, nowW, judLabel, judX, judW);  // 重なり判定(X軸)
            const jresY = judgmentOverlap(nowLabel, nowY, nowH, judLabel, judY, judH);  // 重なり判定(Y軸)

            const nowIndex = nowChilds.indexOf(judLabel);

            if(jresX[0] == "OVERLAP" && jresY[0] == "OVERLAP"){
                if(nowIndex == -1){
                    // child属性に含まれてない、かつ重なっている　→　child属性に登録
                    //console.log("1 paret属性に含まれてなくて、重なっているobj、を登録 objs[Id][child]="+objs[argId]["child"]);
                    objs[argId]["child"].push(judLabel);
                    //console.log("2 paret属性に含まれてなくて、重なっているobj、を登録 objs[Id][child]="+objs[argId]["child"]);
                }
            }else{
                if(nowIndex != -1){
                    // chid属性に含まれてる、かつ重なっていない　→　削除
                    objs[argId]["child"].splice(nowIndex, 1);
                }
            }
        }
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 updateParentChildParam 終了");
}


function changeMenuAreaSize(argArea, argFlg){
    recordConsoleLog(recordConsoleLogFlg, "関数 changeMenuAreaSize 開始");

    const divarea = document.getElementById(argArea);
    const codearea = document.getElementById("codeArea");


    const tmpObjs = JSON.parse(JSON.stringify(objs)); // 深いコピーを作成

    tmpObjs.forEach(loObj => {
        // child配下の値をクリアする
        if (Array.isArray(loObj.child)) {
            loObj.child = [];
        }
    });

    let nowDacset;

    nowDacset = {
        "rule" : dacsetRuleVersion,
        "objs" : tmpObjs,
        "connects" : connects
    }

    let loWidth = "";
    let loHeight = "";

    if(argFlg == "CHANGE"){
        if(menuAreaFlg == "SMALL"){
            menuAreaFlg = "WIDE";
        }else{
            menuAreaFlg = "SMALL";
        }
    }

    if(menuAreaFlg == "WIDE" ){
        loWidth = "100%";
        loHeight = "100%";
        guiOperateFlg = false;  // GUI操作:無効
        codearea.value = JSON.stringify(nowDacset, null, 2);  // textareaにコード(dacset)を登録
    }else{
        loWidth = "100%";
        loHeight = "30px";
        guiOperateFlg = true;  // GUI操作:有効
    }

    divarea.style.width = loWidth;
    divarea.style.height = loHeight;
    recordConsoleLog(recordConsoleLogFlg, "関数 changeMenuAreaSize 終了");
}




function loadDacsetFromArea(){
    // 反映：textareaからコードを読み取り、変数 dacset に格納する
    recordConsoleLog(recordConsoleLogFlg, "関数 loadDacsetFromArea 開始");
    try{
        const codearea = document.getElementById('codeArea');
        const codetext = codearea.value;
        dacset = JSON.parse(codetext);

        if (objs.some(subArray => subArray.length !== 0)) {
            clearArray(objs);  // objsをクリア
        }

        if (connects.some(subArray => subArray.length !== 0)) {
            clearArray(connects);  // connectsをクリア
        }

        objs = dacset["objs"]; // dacsetから図形描画の情報を格納
        objs = sortByGroup(objs);  // group要素の値で昇順に並べ替え
        connects = dacset["connects"]; // dacsetから接続線の情報を格納

        guiOperateFlg = true;
        firstFlow();  // 構成図を再描画
        guiOperateFlg = false;
    }catch (error){
        alert("構成図のコードの読み込み時に問題が発生しました。\nJSONの形式が崩れている可能性が考えられます。");
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 loadDacsetFromArea 終了");
}





// SVGキャンパスを一度クリアして、倍率を変えて再描画する
function changeDivParam(argRatio){
    recordConsoleLog(recordConsoleLogFlg, "関数 changeDivParam 開始");
    scale = argRatio;  // 倍率を設定
    drag = {
        action : null,
        isMouseDown : false,
        id : null, target: null, offsetx: 0, offsety: 0, w: null,h: null,
        cTarget: false, cDifferencex: 0, cDifferencey: 0,
        group: null,
        ctlId: null, ctlTarget: null, ctlElement: null, ctlOffsetx:0, ctlOffsety: 0,
        ctrId: null, ctrTarget: null, ctrElement: null, ctrOffsetx:0, ctrOffsety: 0,
        cblId: null, cblTarget: null, cblElement: null, cblOffsetx:0, cblOffsety: 0,
        cbrId: null, cbrTarget: null, cbrElement: null, cbrOffsetx:0, cbrOffsety: 0,
        rangeX: null, rangeY: null
    }
    nDrag = {
        action : null,
        isMouseDown : false,
        id : null, target: null, offsetx: 0, offsety: 0,
        cTarget: false, cDifferencex: 0, cDifferencey: 0,
        group: null,
        ctlId: null, ctlTarget: null, ctlElement: null, ctlOffsetx:0, ctlOffsety: 0,
        ctrId: null, ctrTarget: null, ctrElement: null, ctrOffsetx:0, ctrOffsety: 0,
        cblId: null, cblTarget: null, cblElement: null, cblOffsetx:0, cblOffsety: 0,
        cbrId: null, cbrTarget: null, cbrElement: null, cbrOffsetx:0, cbrOffsety: 0,
        rangeX: null, rangeY: null
    }

    clearShapes();  // SVGキャンパスをクリア
    setObjectRatio();  // オブジェクトのx,y,w,hをscale倍する
    addObjectFlow();  // SVGキャンパスにオブジェクトを描画
    addConnectFlow();  // SVGキャンパスに接続線を描画
    recordConsoleLog(recordConsoleLogFlg, "関数 changeDivParam 終了");
}


// SVGキャンパスをクリアする
function clearShapes() {
    recordConsoleLog(recordConsoleLogFlg, "関数 clearShapes 開始");
    const svgArea = document.getElementById(SvgArea);
    while (svgArea.firstChild) {
        svgArea.removeChild(svgArea.firstChild);
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 clearShapes 終了");
}

function changeDivArea(argDiv,argParam){
    recordConsoleLog(recordConsoleLogFlg, "関数 changeDivArea 開始");
    let targetElement = document.getElementById(argDiv);

    if(argParam == "NONE"){
        const originalVisibility = targetElement.style.visibility;  // 対象のDIV
        if(originalVisibility=='visible'){
            targetElement.style.visibility = 'hidden';  // DIV表示
        }else{
            targetElement.style.visibility = 'visible';  // DIV非表示
        }
    }else{
        targetElement.style.visibility = argParam;  // DIV表示/非表示
    }
    recordConsoleLog(recordConsoleLogFlg, "関数 changeDivArea 終了");
}


// リンクを張る
function createSvgLinkObject(linkUrl, textContent, x, y) {
    recordConsoleLog(recordConsoleLogFlg, "関数 createSvgLinkObject 開始");
    // SVG要素を取得
    //const svg = document.getElementById(svgId);
    const svg = document.getElementById(SvgArea);

    // <a>要素を作成し、リンク先を設定
    const link = document.createElementNS("http://www.w3.org/2000/svg", "a");
    link.setAttributeNS("http://www.w3.org/1999/xlink", "href", linkUrl);
    link.setAttribute("target", "_blank"); // 新しいタブで開く

    // テキスト要素を作成し、内容と位置を設定
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y);
    text.textContent = textContent;

    // <a>要素にテキスト要素を追加
    link.appendChild(text);

    // SVGにリンク付きオブジェクトを追加
    svg.appendChild(link);
    recordConsoleLog(recordConsoleLogFlg, "関数 createSvgLinkObject 終了");
}

// リンクを張る関数の実行例
//createSvgLinkObject("https://www.yahoo.co.jp/", "Click me!", 150, 150);



/*
function createSvgAnnotatedObject(svgId, textContent, x, y, annotation) {
    // SVG要素を取得
    //const svg = document.getElementById(svgId);
    const svg = document.getElementById(SvgArea);

    // テキスト要素を作成し、内容と位置を設定
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y);
    text.textContent = textContent;

    // 注釈要素を作成し、初期状態では非表示に設定
    const annotationText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    annotationText.setAttribute("x", x);
    annotationText.setAttribute("y", y + 20); // テキストの下に表示
    annotationText.textContent = annotation;
    annotationText.style.display = "none";

    // テキスト要素にクリックイベントを追加
    text.addEventListener("click", () => {
        annotationText.style.display = annotationText.style.display === "none" ? "block" : "none";
    });

    // SVGにテキストと注釈を追加
    svg.appendChild(text);
    svg.appendChild(annotationText);
}

// 使用例
createSvgAnnotatedObject("mySvg", "Click me!", 250, 250, "This is an annotation.");
*/


/*
function createSvgAnnotatedObjectWithAnnotationBackground(svgId, textContent, x, y, annotation, annotationBgColor) {
    // SVG要素を取得
    const svg = document.getElementById(SvgArea);

    // テキスト要素を作成し、内容と位置を設定
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", x);
    text.setAttribute("y", y);
    text.textContent = textContent;

    // 注釈要素を作成し、初期状態では非表示に設定
    const annotationText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    annotationText.setAttribute("x", x);
    annotationText.setAttribute("y", y + 20); // テキストの下に表示
    annotationText.textContent = annotation;
    annotationText.style.display = "none";

    // 注釈のテキストのサイズを取得
    svg.appendChild(annotationText);
    const bbox = annotationText.getBBox();
    svg.removeChild(annotationText);

    // 背景の矩形要素を作成
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", bbox.x - 2);
    rect.setAttribute("y", bbox.y - 2);
    rect.setAttribute("width", bbox.width + 4);
    rect.setAttribute("height", bbox.height + 4);
    rect.setAttribute("fill", annotationBgColor);
    rect.style.display = "none";

    // テキスト要素にクリックイベントを追加
    text.addEventListener("click", () => {
        const isHidden = annotationText.style.display === "none";
        annotationText.style.display = isHidden ? "block" : "none";
        rect.style.display = isHidden ? "block" : "none";
    });

    // SVGにテキスト、背景、注釈を追加
    svg.appendChild(text);
    svg.appendChild(rect);
    svg.appendChild(annotationText);
}

// 使用例
createSvgAnnotatedObjectWithAnnotationBackground("mySvg", "Click me!", 250, 150, "This is an annotation.", "yellow");
*/


</script>
</body>
</html>